#pragma once

#include <iostream>
#include <string>
#include <cstring>
#include <stdexcept>
#include <cstddef>

using namespace std;

class Communicator {
public:
    typedef unsigned short Ip4[4];
    typedef unsigned short Port;

    struct Address {
        Ip4 ip4 = {0, 0, 0, 0};
        Port port;

        Address(const Port& port = 0): port(port) {}

        Address(const Ip4& ip4, const Port& port = 0): port(port) {
            this->ip4[0] = ip4[0];
            this->ip4[1] = ip4[1];
            this->ip4[2] = ip4[2];
            this->ip4[3] = ip4[3];
        }

        Address(const string& address) {
            fromString(address);
        }

        string getIp4String() const {
            return 
                to_string(ip4[0]) + "." +
                to_string(ip4[1]) + "." +
                to_string(ip4[2]) + "." +
                to_string(ip4[3]);
        }

        string toString() const {
            return  getIp4String() + ":" + to_string(port);
        }

        void fromString(const string& address) {
            std::istringstream iss(address);
            
            char dot1, dot2, dot3, colon;
            int octet1, octet2, octet3, octet4, portNumber;

            // Read IP address and port from the string
            iss >> octet1 >> dot1 >> octet2 >> dot2 >> octet3 >> dot3 >> octet4 >> colon >> portNumber;

            if (iss.fail() || dot1 != '.' || dot2 != '.' || dot3 != '.' || colon != ':') {
                throw std::invalid_argument("Invalid address format");
            }

            // Check if each octet and the port number are within valid ranges
            if (octet1 < 0 || octet1 > 255 || octet2 < 0 || octet2 > 255 ||
                octet3 < 0 || octet3 > 255 || octet4 < 0 || octet4 > 255 ||
                portNumber < 0 || portNumber > std::numeric_limits<Port>::max()) {
                throw std::out_of_range("Invalid octet or port number");
            }

            // Set the values
            ip4[0] = static_cast<unsigned short>(octet1);
            ip4[1] = static_cast<unsigned short>(octet2);
            ip4[2] = static_cast<unsigned short>(octet3);
            ip4[3] = static_cast<unsigned short>(octet4);
            port = static_cast<Port>(portNumber);
        }
    };
    
    struct Message {
        static const size_t maxDataSize = 64000;
        char data[maxDataSize];
        size_t length;

        string toString() const {
            return string(data, length);
        }
        
        void fromString(const string& message) {
            size_t size = message.size() + 1;
            if (size >= maxDataSize) 
                throw runtime_error("Too long data");
            strcpy(data, message.c_str());
            data[size] = '\0';
            length = size;
        }

        Message(const string& message) {
            fromString(message);
        }
    };

    typedef struct {
        const char* message;
        int code;
        
        string toString() const {
            return string(message) + " (" + to_string(code) + ")";
        }
    } Error;

    typedef void (*ConnectHandler)(Communicator* comm, const Address& address);
    typedef void (*MessageHandler)(Communicator* comm, const Address& address, const Message& message);
    typedef void (*CloseHandler)(Communicator* comm, const Address& address);
    typedef void (*ErrorHandler)(Communicator* comm, const Error& error);

protected:
    ConnectHandler onConnect;
    MessageHandler onMessage;
    CloseHandler onClose;
    ErrorHandler onError;

    static void defaultConnectHandler(Communicator* comm, const Address& address) {
        cout << "Connect: " << comm->toString() << ": " << address.toString() << endl;
    }

    static void defaultMessageHandler(Communicator* comm, const Address& address, const Message& message) {
        cout << "Message: " << comm->toString() << ": " << address.toString() << ": " << message.toString() << endl;
    }

    static void defaultCloseHandler(Communicator* comm, const Address& address) {
        cout << "Close: " << comm->toString() << ": " << address.toString() << endl;
    }

    static void defaultErrorHandler(Communicator* comm, const Error& error) {
        throw runtime_error(comm->toString() + ": " + error.toString());
    }

public:    
    Communicator(
        ConnectHandler onConnect = defaultConnectHandler,
        MessageHandler onMessage = defaultMessageHandler,
        CloseHandler onClose = defaultCloseHandler,
        ErrorHandler onError = defaultErrorHandler
    ):
        onConnect(onConnect),
        onMessage(onMessage),
        onClose(onClose),
        onError(onError)
    {}

    virtual string toString() const {
        return "Communicator";
    }

    virtual void send(const Message& message, const Address* address = nullptr) {
        throw runtime_error("Unimplemented");
    }
};

class Server: public Communicator {
public:
    using Communicator::Communicator;

    virtual void listen(unsigned short port) {
        throw runtime_error("Unimplemented");
    }
};

class Client: public Communicator {
public:
    using Communicator::Communicator;

    virtual void connect(const Address& address) {
        throw runtime_error("Unimplemented");
    }
};