// #pragma once

// #include <iostream>
// #include <sstream>
// #include <vector>
// #include <map>

// #include <unistd.h>

// #include <X11/Xlib.h>
// #include <X11/Xutil.h>

// #include "Communicator.hpp"
// #include "ChangedRectangle.hpp"

// using namespace std;

// class DesktopClient {
// protected:

//     typedef void (*EventCallback)(DesktopClient*, const ChangedRectangle&);

//     const map<string, EventCallback> eventCallbacks = {
//         { "cr", triggerChangedRectangle },
//     };

//     static void triggerChangedRectangle(DesktopClient* that, const ChangedRectangle& changedRect) {
//         // show updated screen area on the client window
//         cout << "triggerChangedRectangle" << endl;
//         that->showChangedRectangle(changedRect);
//     }

//     bool showChangedRectangle(const ChangedRectangle& changedRect) {
//         cout << "put image" << endl;


//         // Check if the specified region is within the bounds of the window
//         XWindowAttributes windowAttrs;
//         XGetWindowAttributes(display, window, &windowAttrs);

//         if (changedRect.left < 0 || changedRect.top < 0 ||
//             changedRect.left + changedRect.width + windowAttrs.border_width * 2 + 10 >= windowAttrs.width ||
//             changedRect.top + changedRect.height + windowAttrs.border_width * 2 + 10 >= windowAttrs.height) {
//             cout << "Specified region is outside the bounds of the window" << endl;
//             return false;
//         }

//         // Display the ChangedRectangle pixels on the window
//         displayChangedRectangle(changedRect);

//         // // Set up image parameters
//         // const int depth = 24;  // Set the color depth to 24 bits
//         // const int format = ZPixmap;

//         // // Create the XImage
//         // XImage* ximage = XGetImage(display, window, changedRect.left, changedRect.top,
//         //                         changedRect.width, changedRect.height, AllPlanes, format);

//         // if (!ximage) {
//         //     throw runtime_error("Failed to create XImage");
//         // }

//         // cout << "image get OK" << endl;

//         // changedRect.toXImage(*ximage);

//         // cout << "put image" << endl;

//         // XPutImage(display, window, gc, ximage, 0, 0, 
//         //     changedRect.left, changedRect.top, 
//         //     ximage->width, ximage->height
//         // );

//         // cout << "destroy image" << endl; 
//         // XDestroyImage(ximage);

         

//         cout << "image out" << endl;
//         return true;
//     }

//     // Function to display the pixels of a ChangedRectangle on the window
//     void displayChangedRectangle(const ChangedRectangle& rect) {
//         for (int y = rect.top; y < rect.top + rect.height; ++y) {
//             for (int x = rect.left; x < rect.left + rect.width; ++x) {
//                 int pixelIndex = (y - rect.top) * rect.width + (x - rect.left);
//                 if (rect.pixels.size() <= pixelIndex) break;
//                 const ChangedRectangle::RGB& pixelColor = rect.pixels[pixelIndex];

//                 // Assuming putPixel is a global function
//                 putPixel(x, y, pixelColor.r, pixelColor.g, pixelColor.b);
//             }
//         }
//     }

//     void putPixel(int x, int y, uint8_t r, uint8_t g, uint8_t b) {
//         XSetForeground(display, gc, (r << 16) | (g << 8) | b);
//         XDrawPoint(display, window, gc, x, y);
//         XFlush(display);
//     }

//     Communicator& client;
// public:
//     DesktopClient(Communicator& client): 
//         client(client),
//         display(nullptr), 
//         window(0)
//     {
//         init();
//         createWindow();

//         const string serverAddress = "192.168.1.166:12345";

//         cout << "connecting to: [" << serverAddress << "]..." << endl;
//         client.connect(serverAddress);
//         cout << "client connected to: " << serverAddress << endl;
//     }

//     ~DesktopClient() {
//         cleanup();
//     }

//     void runEventLoop() {
//         if (!display) {
//             cerr << "Error: Display not initialized." << endl;
//             return;
//         }

//         client.send("jn");

//         while (true) {
//             // usleep(100000);
//             // if (client.isDataAvailable()) {
//                 // UDPMessage receivedMessage;
//                 // const size_t commBuffSizeMax = 60000;
//                 string receivedData; //(commBuffSizeMax, '\0');
//                 string senderAddress;
//                 int receivedLength = client.recv(receivedData, senderAddress);
//                 cout << "recv:" << receivedLength << ", from: " << senderAddress << endl;
//                 if (receivedLength > 0) {
//                     // EventCallback eventCallback = eventCallbacks.at(receivedMessage.data.substr(0, 2));

//                     // if (eventCallback == triggerChangedRectangle) {
//                         try {
//                             ChangedRectangle receivedRect;
//                             receivedRect.fromString(receivedData);
//                             triggerChangedRectangle(this, receivedRect);
//                         } catch (exception &e) {
//                             cout << "Image recieving error: " << endl;
//                         }
//                     // }
//                 }
//             // }

//             if (!XPending(display)) continue;
//             XEvent event;
//             XNextEvent(display, &event);

//             switch (event.type) {
//                 case KeyPress:
//                     handleKeyPress(event.xkey);
//                     break;

//                 case KeyRelease:
//                     handleKeyRelease(event.xkey);
//                     break;

//                 case ButtonPress:
//                     handleMousePress(event.xbutton);
//                     break;

//                 case ButtonRelease:
//                     handleMouseRelease(event.xbutton);
//                     break;

//                 case MotionNotify:
//                     handleMouseMove(event.xmotion);
//                     break;

//                 case ConfigureNotify:
//                     handleResize(event.xconfigure);
//                     break;

//                 case Expose:
//                     // Handle expose events (redraw if needed)
//                     break;

//                 case ClientMessage:
//                     if (static_cast<unsigned long>(event.xclient.data.l[0]) == wmDeleteMessage)
//                         return;
//                     break;

//                 default:
//                     // Handle other events if needed
//                     break;
//             }
//         }
//     }

// private:
//     Display* display;
//     Window window;
//     GC gc;  // Graphics context
//     Atom wmDeleteMessage;

//     void init() {
//         display = XOpenDisplay(NULL);
//         if (!display) {
//             cerr << "Error: Unable to open display." << endl;
//             exit(EXIT_FAILURE);
//         }

//         wmDeleteMessage = XInternAtom(display, "WM_DELETE_WINDOW", False);
//         XSetWMProtocols(display, DefaultRootWindow(display), &wmDeleteMessage, 1);
//     }

//     void createWindow() {
//         int screen = DefaultScreen(display);

//         window = XCreateSimpleWindow(display, RootWindow(display, screen),
//                                       10, 10, 400, 300, 1,
//                                       BlackPixel(display, screen),
//                                       WhitePixel(display, screen));

//         XSelectInput(display, window, StructureNotifyMask | KeyPressMask | KeyReleaseMask |
//                                        ButtonPressMask | ButtonReleaseMask | PointerMotionMask);

//         XMapWindow(display, window);

//         // Set window title (optional)
//         XStoreName(display, window, "Your Window Title");

//         // Create the GC and store it
//         gc = DefaultGC(display, screen);
        
//         // Flush pending events
//         XFlush(display);
//     }

//     void showImage(int top, int left, XImage* ximage) {
//         XPutImage(display, window, gc, ximage, 0, 0, left, top, ximage->width, ximage->height);
//         XFlush(display);
//     }

//     void cleanup() {
//         if (display) {
//             XDestroyWindow(display, window);
//             XCloseDisplay(display);
//         }
//     }

//     void handleKeyPress(const XKeyEvent& keyEvent) {
//         // Stub method for key press event handling
//         cout << "Key pressed: " << keyEvent.keycode << endl;
//         client.send(("kp" + to_string(keyEvent.keycode)).c_str());
//     }

//     void handleKeyRelease(const XKeyEvent& keyEvent) {
//         // Stub method for key release event handling
//         cout << "Key released: " << keyEvent.keycode << endl;
//         client.send(("kr" + to_string(keyEvent.keycode)).c_str());
//     }

//     void handleMousePress(const XButtonEvent& buttonEvent) {
//         // Stub method for mouse button press event handling
//         cout << "Mouse button pressed: " << buttonEvent.button << endl;
//         client.send(("mp" + to_string(buttonEvent.button)).c_str());
//     }

//     void handleMouseRelease(const XButtonEvent& buttonEvent) {
//         // Stub method for mouse button release event handling
//         cout << "Mouse button released: " << buttonEvent.button << endl;
//         client.send(("mr" + to_string(buttonEvent.button)).c_str());
//     }

//     void handleMouseMove(const XMotionEvent& motionEvent) {
//         // Stub method for mouse move event handling
//         cout << "Mouse moved: (" << motionEvent.x << ", " << motionEvent.y << ")" << endl;
//         client.send(("mm" + to_string(motionEvent.x) + "," + to_string(motionEvent.y)).c_str());
//     }

//     void handleResize(const XConfigureEvent& configureEvent) {
//         // Stub method for window resize event handling
//         cout << "Window resized: " << configureEvent.width << " x " << configureEvent.height << endl;
//         client.send(("wr" + to_string(configureEvent.width) + "," + to_string(configureEvent.height)).c_str());
//     }
// };
