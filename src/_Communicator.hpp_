#pragma once

using namespace std;

class Communicator {
public:

    typedef void (*ClientConnectHandler)(Communicator* that, const string& addr, unsigned short port);
    typedef void (*ClientConnectHandler)(Communicator* that, const string& addr, unsigned short port);

    /**
     * @brief 
     * Implementation is optional,
     * server applications typically use to start waiting for clients.
     * (this function is non-blocking)
     * 
     * @param info (optional) typically used for port number
     * @throw throws an exception when other error occurs
     */
    virtual void listen(ClientConnectHandler onClientConnect, const string& info = "") {
        
    }

    /**
     * @brief 
     * Implementation is optional,
     * client applications use to connect to a server 
     * when multiple clients are possible in the implemented communication.
     * (this function is blocking)
     * 
     * @param addr (optional) typically used for server address in format "ipaddress:port"
     * @throw throws an exception when other error occurs
     */
    virtual void connect(const string& addr = "") {
        
    }

    /**
     * @brief 
     * Implementation is optional,
     * use to close the connection greatfully when the implemented protocol requires
     * (this function is blocking)
     * 
     * @param addr (optional) Typically used by server application to select a connected client. 
     *                        (No address means close all connections)
     * @throw throws an exception when other error occurs
     */
    virtual void close(const string& addr = "") {
        
    }

    /**
     * @brief 
     * Returns true if data available to read with recv function.
     * Should be non-blocking synchronous (returns -1 if no data available)
     * 
     * @param addr (optional) server selects which client's data is available or not
     * @return true data is available to read
     * @return false data is not available to read
     * @throw throws an exception when other error occurs
     */
    virtual bool isDataAvailable(const string& addr = "") {
        throw runtime_error("Implementation is required");
    }

    /**
     * @brief 
     * Recieving binary data and set the addr where the data from.
     * Should be non-blocking synchronous (returns -1 if no data available)
     * 
     * @param data incoming data buffer
     * @param size maximum buffer size in bytes (reading can not reach)
     * @param addr sender address (typical format is "ipaddress:port")
     * @return size_t incoming data size of -1 if there was no available data to read
     * @throw throws an exception when other error occurs
     */
    virtual ssize_t recv(void* data, size_t size, string& addr) {
        throw runtime_error("Implementation is required");
    }

    /**
     * @brief 
     * Sending binary data to the specified address
     * 
     * @param data data to send
     * @param size data size in bytes
     * @param addr (optional) recipient address (typical format is "ipaddress:port")
     * @return size_t sent data size (should match the data parameter size, otherwise sending was not full success)
     * @throw throws an exception when other error occurs
     */
    virtual size_t send(const void* data, size_t size, const string& addr = "") {
        throw runtime_error("Implementation is required");
    }
};
